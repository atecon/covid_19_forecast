function string filename_forecast_plot (const string country,
                                        const string province,
                                        const int MAX_HORIZON[1::],
                                        const bool is_expost)
    /* Compile filename of plot showing expost/ exante interval forecast. */

    string expost = ""
    expost = (is_expost > 0) ? "_expost" : expost

    return sprintf("forecast_arima_maxhorizon_%d_%s_%s%s", \
      MAX_HORIZON, country, province, expost)
end function


function string compile_markdown_plot_cmd (const string folder "Folder where plots are located",
                                           const strings countries "Arrays of countries",
                                           const strings provinces,
                                           const int MAX_HORIZON[1::])
    /* Compile the markdown command for showing both exp-post and
       ex-ante forecasting plots. The resulting string must be added
    to the README.md file. */

    if nelem(countries) != nelem(provinces)
        funcerr "Arrays 'countries' and 'provinces' must be of same length."
    endif

    string markdown_cmd = ""

    loop i=1..nelem(countries) -q
        string pic1 = filename_forecast_plot(countries[i], provinces[i], MAX_HORIZON, 1)
        string pic2 = filename_forecast_plot(countries[i], provinces[i], MAX_HORIZON, 0)
        markdown_cmd += sprintf("<img src=\"%s/%s\" width=\"425\"/> <img src=\"%s\" width=\"425\"/>\n", \
        folder, pic1, pic2)
        markdown_cmd += sprintf("<em>%s - %s</em>\n\n", countries[i], provinces[i])
    endloop

    return markdown_cmd
end function


function list add_future_observations (const list data_set,
                                       const int MAX_HORIZON)
    /*Add future observations of out-of-sample forecasting. */

    list newobs = null
    scalar last_v_id = 2 + nelem(data_set)
    loop i=(1+last_v_id)..(MAX_HORIZON+last_v_id) -q
        list newobs += genseries(sprintf("v%d", i), NA)
    endloop
    return newobs
end function


function void print_panel_details (void)
    printf "\n*** Your panel is ready for analysis.\n"
    printf "\n*** Number of country-province combinations: %d\n", $nobs / $pd
    printf "\n*** Number of observations for each country-province: %d\n", $pd
end function


function series fill_panel_gaps_of_constant (series x)
/* Due to stacking the original data for obtaining a panel,
      some series have gaps now which need to be filled. */

    series ret = x
    ret = (missing(ret)==1) ? pmin(ret) : ret

    return ret
end function

function scalar time_dimension (const list data_set)
    /* Determine time dimension of data set. */

    list L = v*
    return nelem(L)
end function


function strings get_distinct_names (const series x)
    /* Retrieve country/region names and process strings. */
    strings S = strvals(x)
    loop foreach i S -q
        string str = tolower(strstrip(S[i]))
        str = strsub(str, " ", "_")
        str = strsub(str, ",", "")
        S[i] = str
    endloop

    return S
end function

function void print_countries (const strings countries)
    printf "\nData covers the following countries:\n"
    loop foreach i countries -q
        printf "%s\n", countries[i]
    endloop
end function

function string aggregate_data_and_store_csv (const list data_values)
/* Each row of a series refers to confirmed cases in the i-th region,
      and each series captures the confirmed cases over time. */

    matrix mat = {data_values}
    matrix daily_sums = sumc(mat)'
    matrix non_zero_regions_per_day = sumc((mat .> 0))'
    daily_sums ~= non_zero_regions_per_day

    printf "\nData includes information over %d days\n", rows(daily_sums)
    cnameset(daily_sums, "cases_confirmed non_zero_regions")
    string filename = "aggregated_timeseries.csv"
    mat2data(daily_sums, "aggregated_timeseries.csv")
    printf "Succesfully stored aggregated data in file:\n\
      %s/%s", $workdir, filename

    return filename
end function

function list arima_forecast (const series y,
                              const list xlist[null],
                              const int p[0::],
                              const int d[0::],
                              const int q[0::],
                              const int MAX_HORIZON[1::],
                              string *model_properties)
    /* Estimate arima type of model and forecast
    out-of-sample. */

    list L = null
    scalar error = 0
    
    if !exists(xlist)
        list xlist = null
    endif

    smpl ; -MAX_HORIZON
    catch arima p d q; y xlist --quiet
    error = $error
    string model_properties = sprintf("ARIMA(%d,%d,%d)", p, d, q)
    if error
        catch arima 1 1 0 ; y xlist --quiet
        error = $error
        string model_properties = "ARIMA(1,1,0)"
        if error
            catch arima 0 1 0 ; y xlist --quiet
            error = $error
            string model_properties = "ARIMA(0,1,0)"
        endif
    endif
    if error
        return L
    endif

    # Plot multistep  interval forecasts
    fcast --out-of-sample --dynamic --quiet
    smpl full
    series fc_point = $fcast
    series fc_se = $fcse
    list L = y fc_point fc_se

    return L
end function


function void plot_arima_forecast (const series y,
                                   const series fc_point,
                                   const series fc_se,
                                   const string title,
                                   const string filename "Full path or 'display'")
    list L = y fc_point
    string vname = sprintf("%s", argname(y))
    setinfo y --graph-name=@vname

    plot L
        options with-lines time-series single-yaxis
        options band-style=fill
        options band=fc_point,fc_se,1.69726
        literal set key top left
        literal set grid
        printf "set ylabel \"%s\"", argname(y)
        printf "set title \"%s\"", title
    end plot --output="@filename"
end function

